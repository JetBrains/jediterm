package org.jetbrains.jediterm.compose.debug

/**
 * Represents the source of a data chunk in the terminal stream.
 */
enum class ChunkSource {
    /**
     * Data received from the PTY (shell output)
     */
    PTY_OUTPUT,

    /**
     * Data sent by the user (keyboard input)
     */
    USER_INPUT,

    /**
     * Data generated by the emulator (e.g., cursor position reports)
     */
    EMULATOR_GENERATED
}

/**
 * Represents a chunk of data in the terminal stream with metadata.
 *
 * @property index Sequential index of this chunk (0-based)
 * @property timestamp Unix timestamp in milliseconds when chunk was captured
 * @property data The raw character data
 * @property source Where this data came from
 */
data class DebugChunk(
    val index: Int,
    val timestamp: Long,
    val data: CharArray,
    val source: ChunkSource
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as DebugChunk

        if (index != other.index) return false
        if (timestamp != other.timestamp) return false
        if (!data.contentEquals(other.data)) return false
        if (source != other.source) return false

        return true
    }

    override fun hashCode(): Int {
        var result = index
        result = 31 * result + timestamp.hashCode()
        result = 31 * result + data.contentHashCode()
        result = 31 * result + source.hashCode()
        return result
    }
}

/**
 * Represents a snapshot of terminal state at a specific point in time.
 *
 * @property chunkIndex Index of the chunk when this snapshot was taken
 * @property timestamp Unix timestamp in milliseconds
 * @property screenLines Content of the screen buffer (visible lines)
 * @property styleLines Style attributes for each character in screen buffer
 * @property historyLines Content of the scrollback history
 * @property cursorX Cursor X position (column, 0-based)
 * @property cursorY Cursor Y position (row, 0-based)
 * @property styleState Serialized current style state (colors, bold, italic, etc.)
 * @property alternateBufferActive Whether the alternate screen buffer is active
 * @property scrollRegionTop Top line of scroll region (0-based, null = none)
 * @property scrollRegionBottom Bottom line of scroll region (0-based, null = none)
 */
data class TerminalSnapshot(
    val chunkIndex: Int,
    val timestamp: Long,
    val screenLines: String,
    val styleLines: String,
    val historyLines: String,
    val cursorX: Int,
    val cursorY: Int,
    val styleState: String,
    val alternateBufferActive: Boolean = false,
    val scrollRegionTop: Int? = null,
    val scrollRegionBottom: Int? = null
)

/**
 * Type of terminal buffer to display in the debug view.
 */
enum class BufferType {
    /**
     * The current screen buffer (visible terminal content)
     */
    SCREEN,

    /**
     * Style attributes for each character (colors, bold, etc.)
     */
    STYLE,

    /**
     * Scrollback history buffer
     */
    HISTORY
}

/**
 * Settings for control sequence visualization.
 *
 * @property showChunkIds Whether to show chunk IDs in sequence log
 * @property showInvisibleChars Whether to show invisible characters (spaces, tabs, etc.)
 * @property wrapLines Whether to wrap long lines in sequence view
 * @property useTeseq Whether to use external GNU teseq tool for visualization (if available)
 * @property colorCodeSequences Whether to color-code escape sequences (ESC=red, CSI=blue, OSC=green)
 */
data class VisualizationSettings(
    val showChunkIds: Boolean = true,
    val showInvisibleChars: Boolean = true,
    val wrapLines: Boolean = true,
    val useTeseq: Boolean = false,
    val colorCodeSequences: Boolean = true
)
